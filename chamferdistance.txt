    for(var i =0; i < outerLoop; i++)
    {
      for(var j=0; j< innerLoop; j++)
      {

        min_x.push(Math.abs(outerLoopArr[i][1] - innerLoopArr[j][1]));
        min_y.push(Math.abs(outerLoopArr[i][2] - innerLoopArr[j][2]));
        min_o.push(Math.abs(i - j));

      }

      // basically adds up min_x[i] + min_y[i] + min_o[i]
      var sum = min_x.map(function (num, idx) {
          return num + min_y[idx] + min_o[idx];
        }
      );


      indexOfMin = sum.indexOf(Math.min(...sum));

      if(currentIndexOfMin == 0)
      {
        ModifiedMinValue = Math.min(...sum);
      }
      if(currentIndexOfMin != 0 && indexOfMin == currentIndexOfMin)
      {
        ModifiedMinValue = Math.min(...sum);
        ModifiedMinValue++;
      }


      maxDifference = maxDifference + ModifiedMinValue;
      min_x = [], min_y = [] , min_o = [], sum = [];



    }

    var ChamferDistance = Math.round(((Math.pow(maxDifference,2))/outerLoop)*100)/100;

    var similarityScore = Math.round((1-((ChamferDistance)/(ChamferDistance + curveAdjuster)))*100);

    // console.log('ChamferDistance: ',ChamferDistance)

  // use objects instead of arrays since arrays are limited, and hard to identify using its columns only
    var temp_obj = new Object();
    temp_obj.ChamferDistance = ChamferDistance;
    temp_obj.index = parseInt(index);
    temp_obj.minTime = minTime;
    temp_obj.maxTime = maxTime;
    temp_obj.similarityScore = similarityScore;



    // result.push(temp_obj);


    return temp_obj;
  }
